import { GoogleGenAI, Content, Part, GenerateContentResponse } from "@google/genai"; // Correct class name
import { logger } from 'genkit/logging'; // Assuming genkit logger is available/appropriate here

// --- Define Grounding Metadata Structures (based on documentation) ---
// Note: These might need adjustment if the SDK provides specific types.
interface GroundingChunkWeb {
  uri: string;
  title: string;
}

interface GroundingChunk {
  web: GroundingChunkWeb;
}

interface SearchEntryPoint {
  renderedContent: string; // HTML/CSS for search suggestion chip
}

export interface GroundingMetadata { // Exporting for use in the flow
  webSearchQueries?: string[];
  searchEntryPoint?: SearchEntryPoint;
  groundingChunks?: GroundingChunk[];
  // groundingSupports might also be useful, but let's start with chunks
}

/**
 * Represents the result of a grounded search, including content and citations.
 */
export interface GroundedSearchResult {
  /**
   * The main content generated by the model, potentially summarizing search results.
   */
  content: string;
  /**
   * Metadata containing citation information (grounding chunks) and search suggestions.
   */
  metadata?: GroundingMetadata;
}

// Ensure the API key is loaded (assuming it's in process.env.GEMINI_API_KEY)
// It's better practice to handle API key loading where Genkit/AI instance is initialized,
// but for this standalone function, we check here. Ensure this doesn't conflict with Genkit's setup.
const apiKey = process.env.GEMINI_API_KEY;
if (!apiKey) {
  // Log an error, but maybe don't throw immediately if Genkit handles initialization elsewhere.
  // Throwing here might break the app if the key is loaded later by Genkit.
  // Consider how API keys are managed in your project (e.g., in ai-instance.ts).
  logger.error("GEMINI_API_KEY environment variable not set at googleSearch initialization.");
  // For now, let's proceed assuming Genkit/GoogleGenAI handles the key internally if provided during its setup.
  // If errors occur later, this is a likely cause.
}

// Initialize GenAI - Ensure this doesn't conflict with Genkit's ai() instance if it uses the same key/config.
// It might be better to get the configured GenAI instance from Genkit if possible.
const genAI = new GoogleGenAI({ apiKey: apiKey || "" }); // Pass options object


/**
 * Asynchronously retrieves grounded search results for a given query using Gemini.
 *
 * @param query The search query.
 * @returns A promise that resolves to a GroundedSearchResult object containing
 *          the generated content and grounding metadata (citations).
 */
export async function googleSearch(query: string): Promise<GroundedSearchResult> {
  logger.info(`[googleSearch] Performing grounded search for query: "${query}"`);

  // Defensive check for API key again, in case initialization allowed empty string
  if (!apiKey) {
      logger.error("[googleSearch] Cannot perform search: GEMINI_API_KEY is missing.");
      throw new Error("Google Search failed: API key is missing.");
  }

  try {
    const contents: Content[] = [{ role: "user", parts: [{ text: query }] }];

    // Call generateContent directly on genAI.models, specifying model and tools here
    const result: GenerateContentResponse = await genAI.models.generateContent({
        model: "gemini-1.5-flash-latest", // Specify the model here
        contents: contents,
        // Tools need to be inside a 'config' object
        config: {
            tools: [{ googleSearchRetrieval: {} }], // Use 'googleSearchRetrieval' for 1.5 models
        },
        // Optional: generationConfig: { ... }
    });

    // Access candidates directly from the result
    if (!result || !result.candidates || result.candidates.length === 0) {
      logger.warn(`[googleSearch] No candidates returned for query: "${query}"`);
      // Return empty content but potentially still include metadata if available (though unlikely)
      // Check if metadata exists even without candidates (unlikely but possible)
      const metadata = result?.candidates?.[0]?.groundingMetadata as GroundingMetadata | undefined;
      return { content: "", metadata: metadata };
    }

    // Extract content and metadata from the first candidate
    const candidate = result.candidates[0];
    // Ensure all parts are joined correctly, handling potential non-text parts if necessary (though unlikely for search)
    // Add explicit type 'Part' to the map parameter
    const content = candidate.content?.parts?.map((part: Part) => part.text ?? '').join('') || '';
    // Type assertion might be needed if the SDK types aren't precise enough or if structure varies
    const metadata = candidate.groundingMetadata as GroundingMetadata | undefined;

    logger.info(`[googleSearch] Search successful. Content length: ${content.length}, Metadata found: ${!!metadata}`);
    if (metadata?.groundingChunks) {
        logger.debug(`[googleSearch] Found ${metadata.groundingChunks.length} grounding chunks (citations).`);
    }
     if (metadata?.webSearchQueries) {
        logger.debug(`[googleSearch] Found ${metadata.webSearchQueries.length} web search queries.`);
    }


    return {
      content: content,
      metadata: metadata,
    };

  } catch (error: any) {
    logger.error(`[googleSearch] Error during search for query "${query}": ${error.message}`, error);
    // Re-throw or return a specific error structure if needed by the calling flow
    // Consider the impact on the overall flow if search fails.
    // Check if the error is likely a rate limit error (429)
    // The actual error structure might vary, so checking message/status code is a common approach
    const errorMessage = error.message || '';
    if (errorMessage.includes('429') || errorMessage.toLowerCase().includes('resource_exhausted')) {
        logger.warn(`[googleSearch] Search skipped due to rate limiting (429 Too Many Requests) for query "${query}".`);
        // Return an empty result to allow the flow to continue without search data
        return { content: "", metadata: undefined };
    } else {
        // For other errors, re-throw to indicate a more critical failure
        throw new Error(`Google Search failed: ${errorMessage}`);
    }
  }
}
